A1:函数参数的寄存器为 a0~a7； printf 的 13 存在寄存器 a2 中
A2:在C代码中，main调用f，f调用g。而在生成的汇编中，main函数进行了内联优化处理。在 40 行可以看到, 编译器进行了函数内联, 直接将 f(8)+1的值 12 计算出来了. 从代码li a1,12可以看出，main直接计算出了结果并储存。
A3:由第 43 和 44 行可以看出, jalr 跳转的地址为 0x30+1536=0x630, 即函数 printf 的地址为 0x630
A4:jalr 指令会将 pc + 4 赋给当前寄存器，刚好是其下一条指令的地址。根据 jalr 指令的功能, 在刚跳转后 ra 的值为 pc+4=0x34+4=0x38
A5:He110 World; 0x726c6400; 不需要，57616 的十六进制是 110，无论端序（十六进制和内存中的表示不是同个概念） 
A6:根据函数的传参规则, y= 后跟的值应该为寄存器 a2 的值。 因为 `printf` 尝试读的参数数量比提供的参数数量多。 第二个参数 `3` 通过 a1 传递，而第三个参数对应的寄存器 a2 在调用前不会被设置为任何具体的值，而是会 包含调用发生前的任何已经在里面的值。